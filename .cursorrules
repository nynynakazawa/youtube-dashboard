# YouTube Dashboard プロジェクトルール

## 基本原則

### 1. 宣言的なコード（Declarative Code）
- 命令的な実装（how）ではなく、何をしたいか（what）を明確に表現する
- 状態の変更は明示的に行い、副作用を最小限に抑える
- React/Next.jsでは、JSXで宣言的にUIを記述する
- ループ処理は`map`、`filter`、`reduce`などの関数型メソッドを使用
- 条件分岐は早期リターンや三項演算子を活用して可読性を向上させる

### 2. DRY原則（Don't Repeat Yourself）
- 同じロジックやコードの重複を避ける
- 3回以上使用されるコードは関数やコンポーネントとして抽出する
- 共通のユーティリティ関数は`utils/`または`lib/`ディレクトリに配置
- 再利用可能なコンポーネントは`components/`ディレクトリに配置
- 定数や設定値は`constants/`または`config/`に集約
- 型定義の重複を避け、共通の型は`types/`ディレクトリに配置

### 3. 拡張を見据えたコード設計
- 将来の機能追加や変更を考慮した柔軟な設計を心がける
- インターフェースや抽象化を適切に使用し、実装の詳細を隠蔽する
- 設定や環境変数は外部化し、ハードコーディングを避ける
- プラグインやモジュール化可能な構造を意識する
- 単一責任の原則（SRP）に従い、各モジュールは一つの責任のみを持つ
- 依存性の注入やファクトリーパターンを活用して結合度を下げる

### 4. 無駄なフォールバックはしない
- 不要なデフォルト値やフォールバック処理を追加しない
- エラーハンドリングは必要最小限に留める
- 過度なnullチェックやundefinedチェックは避ける（TypeScriptの型システムを活用）
- 実際にエラーが発生する可能性がある箇所のみエラーハンドリングを実装
- 不要なtry-catchブロックは使用しない
- オプショナルチェーン（`?.`）やnull合体演算子（`??`）は必要な場合のみ使用

### 5. 不要なコードやファイルの削除
- 使用されていないインポート、変数、関数、コンポーネントは削除する
- コメントアウトされたコードは削除する（Git履歴に残るため）
- 未使用のファイルやディレクトリは削除する
- デッドコードや到達不可能なコードは削除する
- リファクタリング後は古いコードを確実に削除する
- 一時的なデバッグコードやconsole.logは本番コードに残さない

### 6. 分かりやすいルール化された階層構造
- プロジェクトのディレクトリ構造は一貫性を保つ
- ファイル名は明確で一貫した命名規則に従う（例: `PascalCase` for components, `camelCase` for utilities）
- 関連するファイルは同じディレクトリに配置する
- ディレクトリ名は複数形を使用（例: `components/`, `utils/`, `types/`）
- 各ディレクトリの役割を明確に定義する

## ディレクトリ構造のルール

```
app/                    # Next.js App Router
├── (routes)/          # ルートグループ
├── components/         # ページ固有のコンポーネント
├── layout.tsx         # レイアウト
└── page.tsx           # ページ

components/             # 再利用可能な共通コンポーネント
├── ui/                # UIプリミティブコンポーネント
└── features/          # 機能別コンポーネント

lib/                    # ライブラリ設定や初期化
utils/                  # ユーティリティ関数
types/                  # TypeScript型定義
constants/              # 定数
hooks/                  # カスタムフック
```

## コーディング規約

### TypeScript
- 型推論を活用し、明示的な型アノテーションは必要な場合のみ使用
- `any`型の使用は避け、`unknown`や適切な型定義を使用
- インターフェースとタイプエイリアスの使い分けを明確にする
- ジェネリクスを活用して再利用性を高める

### React/Next.js
- コンポーネントは関数コンポーネントを使用
- カスタムフックでロジックを分離する
- パフォーマンス最適化（`useMemo`、`useCallback`）は必要な場合のみ使用
- Server Componentsを優先し、クライアントコンポーネントは必要な場合のみ使用

### 命名規則
- コンポーネント: `PascalCase`（例: `UserProfile.tsx`）
- 関数・変数: `camelCase`（例: `getUserData`）
- 定数: `UPPER_SNAKE_CASE`（例: `API_BASE_URL`）
- 型・インターフェース: `PascalCase`（例: `UserData`）
- ファイル名: コンポーネントは`PascalCase`、その他は`camelCase`

### インポート順序
1. 外部ライブラリ（React, Next.js等）
2. 内部モジュール（@/components, @/utils等）
3. 相対パスインポート
4. 型インポート（`import type`）

### コメント
- 複雑なロジックには説明コメントを追加
- 関数やコンポーネントにはJSDocコメントを追加（公開APIの場合）
- 自明なコードにはコメントを追加しない
- TODOコメントは避け、Issueやタスク管理ツールを使用

## エラーハンドリング

- エラーは適切なレベルでキャッチし、ユーザーに分かりやすいメッセージを表示
- エラーログは構造化された形式で記録
- 予期しないエラーは上位に伝播させる
- リトライロジックは必要な場合のみ実装

## パフォーマンス

- 不要な再レンダリングを避ける
- 画像は最適化された形式を使用（Next.js Imageコンポーネント）
- コード分割を適切に使用
- バンドルサイズを意識し、不要な依存関係を避ける

## セキュリティ

- ユーザー入力は必ず検証・サニタイズする
- 機密情報は環境変数で管理
- APIキーやトークンはクライアント側に露出しない
- XSSやCSRF対策を適切に実装

## テスト

- 重要なビジネスロジックにはテストを書く
- テストは実装と同時に書く（TDDを推奨）
- テストファイルは対象ファイルと同じディレクトリに`*.test.ts`または`*.spec.ts`として配置

## Gitコミット

- コミットメッセージは明確で日本語で説明的にする
- 1つのコミットは1つの変更に集中する
- 不要なファイル（node_modules、.env等）はコミットしない