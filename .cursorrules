# YouTube Dashboard プロジェクトルール

## 基本原則

### 1. 宣言的なコード（Declarative Code）
- 命令的な実装（how）ではなく、何をしたいか（what）を明確に表現する
- 状態の変更は明示的に行い、副作用を最小限に抑える
- React/Next.jsでは、JSXで宣言的にUIを記述する
- ループ処理は`map`、`filter`、`reduce`などの関数型メソッドを使用
- 条件分岐は早期リターンや三項演算子を活用して可読性を向上させる

### 2. DRY原則（Don't Repeat Yourself）
- 同じロジックやコードの重複を避ける
- 3回以上使用されるコードは関数やコンポーネントとして抽出する
- 共通のユーティリティ関数は`utils/`または`lib/`ディレクトリに配置
- 再利用可能なコンポーネントは`components/`ディレクトリに配置
- 定数や設定値は`constants/`または`config/`に集約
- 型定義の重複を避け、共通の型は`types/`ディレクトリに配置

### 3. 拡張を見据えたコード設計
- 将来の機能追加や変更を考慮した柔軟な設計を心がける
- インターフェースや抽象化を適切に使用し、実装の詳細を隠蔽する
- 設定や環境変数は外部化し、ハードコーディングを避ける
- プラグインやモジュール化可能な構造を意識する
- 単一責任の原則（SRP）に従い、各モジュールは一つの責任のみを持つ
- 依存性の注入やファクトリーパターンを活用して結合度を下げる

### 4. 無駄なフォールバックはしない
- 不要なデフォルト値やフォールバック処理を追加しない
- エラーハンドリングは必要最小限に留める
- 過度なnullチェックやundefinedチェックは避ける（TypeScriptの型システムを活用）
- 実際にエラーが発生する可能性がある箇所のみエラーハンドリングを実装
- 不要なtry-catchブロックは使用しない
- オプショナルチェーン（`?.`）やnull合体演算子（`??`）は必要な場合のみ使用

### 5. 不要なコードやファイルの削除
- 使用されていないインポート、変数、関数、コンポーネントは削除する
- コメントアウトされたコードは削除する（Git履歴に残るため）
- 未使用のファイルやディレクトリは削除する
- デッドコードや到達不可能なコードは削除する
- リファクタリング後は古いコードを確実に削除する
- 一時的なデバッグコードやconsole.logは本番コードに残さない
- 開発中は積極的にデバッグログや日本語コメントを追加するが、プロジェクト完成後はスクリプトで一括削除する方針とする

### 6. 分かりやすいルール化された階層構造
- プロジェクトのディレクトリ構造は一貫性を保つ
- ファイル名は明確で一貫した命名規則に従う（例: `PascalCase` for components, `camelCase` for utilities）
- 関連するファイルは同じディレクトリに配置する
- ディレクトリ名は複数形を使用（例: `components/`, `utils/`, `types/`）
- 各ディレクトリの役割を明確に定義する

## ディレクトリ構造のルール

```
app/                    # Next.js App Router
├── (routes)/          # ルートグループ
├── components/         # ページ固有のコンポーネント
├── layout.tsx         # レイアウト
└── page.tsx           # ページ

components/             # 再利用可能な共通コンポーネント
├── ui/                # UIプリミティブコンポーネント
└── features/          # 機能別コンポーネント

lib/                    # ライブラリ設定や初期化
utils/                  # ユーティリティ関数
types/                  # TypeScript型定義
constants/              # 定数
hooks/                  # カスタムフック
```

## コーディング規約

### TypeScript
- 型推論を活用し、明示的な型アノテーションは必要な場合のみ使用
- `any`型の使用は避け、ジェネリック型や`unknown`や適切な型定義を使用
- インターフェースとタイプエイリアスの使い分けを明確にする
- ジェネリクスを活用して再利用性を高める

### React/Next.js
- コンポーネントは関数コンポーネントを使用
- カスタムフックでロジックを分離する
- パフォーマンス最適化（`useMemo`、`useCallback`）は必要な場合のみ使用
- Server Componentsを優先し、クライアントコンポーネントは必要な場合のみ使用

### 命名規則
- コンポーネント: `PascalCase`（例: `UserProfile.tsx`）
- 関数・変数: `camelCase`（例: `getUserData`）
- 定数: `UPPER_SNAKE_CASE`（例: `API_BASE_URL`）
- 型・インターフェース: `PascalCase`（例: `UserData`）
- ファイル名: コンポーネントは`PascalCase`、その他は`camelCase`

### インポート順序
1. 外部ライブラリ（React, Next.js等）
2. 内部モジュール（@/components, @/utils等）
3. 相対パスインポート
4. 型インポート（`import type`）

### コメント
- 複雑なロジックには説明コメントを追加
- 関数やコンポーネントにはJSDocコメントを追加（公開APIの場合）
- 自明なコードにはコメントを追加しない
- TODOコメントは避け、Issueやタスク管理ツールを使用
- 開発中は積極的に日本語のコメントを追加し、処理の意図や動作を明確に記述する
- デバッグログ（console.log、logger.debug等）も開発中は積極的に追加し、後で確認できるようにする

## エラーハンドリング

- エラーは適切なレベルでキャッチし、ユーザーに分かりやすいメッセージを表示
- エラーログは構造化された形式で記録
- 予期しないエラーは上位に伝播させる
- リトライロジックは必要な場合のみ実装

## パフォーマンス

- 不要な再レンダリングを避ける
- 画像は最適化された形式を使用（Next.js Imageコンポーネント）
- コード分割を適切に使用
- バンドルサイズを意識し、不要な依存関係を避ける

## セキュリティ

- ユーザー入力は必ず検証・サニタイズする
- 機密情報は環境変数で管理
- APIキーやトークンはクライアント側に露出しない
- XSSやCSRF対策を適切に実装

## テスト

- 重要なビジネスロジックにはテストを書く
- テストは実装と同時に書く（TDDを推奨）
- テストファイルは対象ファイルと同じディレクトリに`*.test.ts`または`*.spec.ts`として配置

## バックエンド開発

### N+1問題の回避
- データベースクエリは可能な限りJOINやサブクエリを使用して1回のクエリで取得する
- ループ内でのデータベースアクセスは避け、バッチ処理や一括取得を優先する
- ORMを使用する場合は、`select_related`や`prefetch_related`などの最適化機能を活用する
- 複数のレコードを挿入・更新する場合は、バルクインサートやバルクアップデートを使用する
- 例: ループ内で個別にINSERTするのではなく、`executemany()`やバッチINSERTを使用

### ブロッキングとノンブロッキングの使い分け
- I/O待機が発生する処理（API呼び出し、データベースアクセス、ファイル操作）は非同期処理を検討する
- 複数の独立したI/O処理がある場合は、並列実行を優先する
- CPU集約的な処理は同期的に実行し、I/O待機が発生する処理は非同期に実行する
- 非同期処理には`asyncio`、`concurrent.futures`、`Promise.all`などを適切に使用する
- Lambda関数など実行時間に制限がある環境では、並列処理で実行時間を短縮する

### 並列処理の実装
- 複数の独立したAPIリクエストは`Promise.all`（JavaScript/TypeScript）や`asyncio.gather`（Python）で並列実行する
- データベースのバッチ操作は`executemany()`やバルク操作を使用する
- 並列処理が可能な場合は、順次処理を避けて並列処理を実装する
- 並列処理の数は適切に制限し、リソースの枯渇を防ぐ（例: `Semaphore`、`concurrent.futures.ThreadPoolExecutor`の`max_workers`）
- エラーハンドリングは各並列処理で個別に行い、一部の失敗が全体に影響しないようにする

### 冪等性の確保
- APIエンドポイントは可能な限り冪等性を保証する（同じリクエストを複数回実行しても同じ結果になる）
- データベースのINSERT操作は`ON DUPLICATE KEY UPDATE`や`UPSERT`を使用して冪等性を確保する
- 更新操作は`WHERE`句で条件を明確にし、期待する状態でのみ更新が実行されるようにする
- 外部APIを呼び出す場合は、リトライ時に冪等性を考慮した実装にする
- 冪等性を保証できない操作は、トランザクションやロック機構を使用して重複実行を防ぐ

### データベース最適化
- インデックスを適切に設定し、クエリパフォーマンスを最適化する
- N+1問題を避けるため、JOINやサブクエリを活用する
- 大量のデータを扱う場合は、ページネーションやカーソルベースのページングを実装する
- 接続プールを適切に設定し、接続の再利用を最適化する
- トランザクションのスコープを最小限にし、ロック時間を短縮する

### API設計
- RESTfulな設計原則に従う
- 適切なHTTPステータスコードを使用する
- リクエスト/レスポンスの形式を統一する
- レート制限を実装し、APIの過剰な使用を防ぐ
- バージョニングを適切に実装する

## 外部サービス操作

### 状態確認とログ確認
- GCP、AWS、Vercelなどの外部サービスの状態確認は基本的にCLIを使用する
- ログや構造を確認しながら作業を進める
- `aws logs`、`gcloud logging`、`vercel logs`などのコマンドを活用して現在の状態を把握する
- リソースの一覧表示や設定の確認は積極的に行う（`aws list`、`gcloud list`など）

### 危険な操作の制限
以下の操作は基本的に実行しない。必要不可欠な場合のみ、ユーザーの明示的な承認を得てから実行する：
- コンテナの新規作成（ECS、Cloud Run、Kubernetesなど）
- 設定変更（セキュリティグループ、IAMポリシー、ネットワーク設定など）
- 関数の削除（Lambda、Cloud Functionsなど）
- 環境変数の変更（特に本番環境）
- 機密情報のアップロード（APIキー、パスワード、トークンなど）
- データベースの削除やスキーマ変更
- リソースの削除全般

### 確認プロンプトの実装
- 危険な操作を実行する必要がある場合は、CLI上で確認プロンプトを表示し、"y"を入力しないと進めないようにする
- 例: `--yes`フラグを必須にせず、対話形式で確認を求める
- 実行前に影響範囲とリスクを明確に説明する

### データ構造の理解
- バックエンドのデータ構造を理解しながら作業を進める
- DynamoDBやRDB（PostgreSQL、MySQLなど）の確認用スクリプトを作成し、テーブル構造やデータの状態を確認できるようにする
- 確認用スクリプトは`scripts/`ディレクトリに配置し、`check-dynamodb.ts`、`check-rdb.ts`などの命名規則に従う
- スクリプトは読み取り専用の操作（SELECT、スキャンなど）を中心に実装し、データの変更は行わない
- データ構造の変更が必要な場合は、マイグレーションスクリプトを作成し、十分な検証を行ってから実行する

## Gitコミット

- コミットメッセージは明確で日本語で説明的にする
- 1つのコミットは1つの変更に集中する
- 不要なファイル（node_modules、.env等）はコミットしない